package address_class_2;

//Rowan Turner
//May 5, 2018
//CS 64
//Final Project
//TreeSet implementation

import java.io.*;
import java.util.*;

/**
 * Class that builds two parallel TreeSets of AddressInfos, one ordered by Name and one by Address. Has add, search, delete, toString and save file methods.
 * @author Rowan
 *
 */
public class AddressInfoCollection {
	/**
	 * List that will be ordered by Name
	 */
	private TreeSet<AddressInfo> myAlphaCollection;
	/**
	 * List that will be ordered by Address
	 */
	private TreeSet<AddressInfo> myAddressCollection;
	
	/**
	 * Zero parameter constructor. Creates two lists, one ordered by Address, one by Name
	 */
	public AddressInfoCollection() {
		myAlphaCollection = new TreeSet<>();
		myAddressCollection = new TreeSet<>(AddressInfo.ADDRESS_COMPARATOR);
	}//constructor
	
	/**
	 * Searches for and returns a reference to an AddressInfo
	 * @param findMe The AddressInfo to be searched for
	 * @return Returns a reference to the AddressInfo searched for. Null if not found.
	 */
	public AddressInfo search (AddressInfo findMe) {
		if (myAlphaCollection.contains(findMe)) {
			for (AddressInfo current : myAlphaCollection) {
				if(current.equals(findMe)){
					return current;
				}//if
			}//for - iterates the list
		}//if
		return null;
	}//search
	
	/**
	 * Adds AddressInfos to both lists. Does not allow duplicate Names
	 * @param addMe The AddressInfo to be added
	 * @return Returns true if add was successful, false otherwise
	 */
	public boolean add(AddressInfo addMe) {
		return (myAlphaCollection.add(addMe)&&myAddressCollection.add(addMe));
	}//add
	
	/**
	 * Deletes the specified AddressInfo from both lists
	 * @param deleteMe The AddressInfo to be deleted
	 * @return Returns true if delete was successful, false otherwise
	 */
	public boolean delete(AddressInfo deleteMe) {
		return (myAlphaCollection.remove(deleteMe)&&myAddressCollection.remove(deleteMe));
	}//delete
	
	/**
	 * Returns a string representation of the data in the Name ordered list
	 * @return Returns the toString called on myAlphaCollection
	 */
	public String toStringAlphabetical() {
		StringBuilder sb = new StringBuilder("");
		for(AddressInfo current: myAlphaCollection) {
			sb.append(current.toString());
		}//for
		return sb.toString();
	}//toStringAlphabetical
	
	/**
	 * Returns a string representation of the data in the Address ordered list
	 * @return Returns the toString called on myAddressCollection
	 */
	public String toStringByAddress() {
		StringBuilder sb = new StringBuilder("");
		for(AddressInfo current: myAddressCollection) {
			sb.append(current.toString());
		}//for
		return sb.toString();
	}//toStringByAddress
	
	/**
	 * Saves the data from myAlphaCollection to a file
	 * @param fileName The name of the file to be saved to
	 * @return Returns a string generated by the saveToFile method of the list which indicates any save exceptions
	 */
	public String saveToFile(String fileName) {
		String toReturn ="";
		try {
			ObjectOutputStream oOS = new ObjectOutputStream (new FileOutputStream(fileName));
			Iterator<AddressInfo> itr = myAlphaCollection.iterator();
			while (itr.hasNext()) {
				oOS.writeObject(itr.next());
			}//while
			oOS.flush();
			oOS.close();
		}//try
		catch (Exception e) {
			toReturn += e.toString();
		}//catch
		return toReturn;
	}//saveToFile
	
	/**
	 * Loads the data from a file into both lists. Disallows duplicate entries
	 * @param fileName The file to be loaded from
	 * @return Returns a string representing each AddressInfo in the file, if it added that AddressInfo and any error messages generated 
	 */
	public String loadFromFile(String fileName) {
		String toReturn = "";
		try {
			ObjectInputStream oIS = new ObjectInputStream(new FileInputStream(fileName));
			while (true) {
				AddressInfo fromFile = (AddressInfo) (oIS.readObject());
				if (!myAlphaCollection.contains(fromFile)) { // object not already in List
					if (add(fromFile)) {
						toReturn += fromFile + "successfully added to List.\n";
					} else {
						toReturn += fromFile + "not successfully added to List.\n";
					} // inner else
				} else {
					toReturn += fromFile + "already in DB.\n" + "Record not added from file!\n";
				} // else
			} // while
		} // try
		catch (EOFException eOF) {
		} // catch as planned
		catch (Exception e) {
			toReturn += e;
		} // catch other problem
		return toReturn;
	}//loadFromFile
	
}//AddressInfoCollection
